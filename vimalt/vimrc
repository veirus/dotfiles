if &cp | set nocp | endif
" XXX: prevents unexpected shit from happening:
" XXX: as result netrw, showmatch will fail
" XXX: use for :debug:
" set noloadplugins

set nobackup
set noswapfile
set viminfo='50,<1000,s100,:20
if !has('nvim')
	" XXX: if set this hangs or crashes nvim:
	set viminfo+=n~/vimfiles/tmp/viminfo
endif

set encoding=utf-8
set keymap=russian-jcukenwin
set iminsert=0

" visual xpenb {{{1
if has('gui_running')
	set gfn=Droid_Sans_Mono_Slashed_for_Pow:h12:cRUSSIAN:qCLEARTYPE,Source_Code_Pro:h12:cRUSSIAN:qCLEARTYPE,Consolas:h12
	set guioptions=ac
endif

set novb t_vb=
set number
set relativenumber
set ruler

" statusline {{{2

set laststatus=2
runtime stl4.vim

" statusline }}}2

if &listchars ==# 'eol:$'
	set listchars=tab:\â”‚\ ,trail:Â·,extends:Â»,precedes:Â«,nbsp:+
	set list
endif

set showmatch
set matchtime=2

set linebreak
let &showbreak='â”— '
set breakindent

set scrolloff=5
set sidescroll=5

" cures some of "press <cr> to continue" messages
set cmdheight=2
set shortmess+=filmnrwxaoOstTWAIcF
" }}}1

set hidden

set incsearch

set ignorecase
set smartcase

set wildmenu
" Command <Tab> completion, list matches, then longest common part, then all.
set wildmode=list:longest,full

set omnifunc=syntaxcomplete#Complete

if has('virtualedit')
	set virtualedit=block
endif
set backspace=indent,eol,start
set nojoinspaces

" fuck 'r', fuck 'o' and fuck automagical addition of shit in my lines
set formatoptions=qnl1j

" maps {{{1
let g:mapleader = "\<Space>"

" evil and heresy {{{2
nnoremap <C-c><C-s> :up<CR>
inoremap <C-c><C-s> <C-o>:up<CR>
nnoremap <M-x> :
inoremap <M-x> <C-o>:

" Auto-delete closing parenthesis/brace {{{1
function! BetterBackSpace() abort
	let cur_line = getline('.')
	let before_char = cur_line[col('.')-2]
	let after_char = cur_line[col('.')-1]
	if (before_char == '(' && after_char == ')') || (before_char == '{' && after_char == '}') || (before_char == '[' && after_char == ']')
		return "\<Del>\<BS>"
	else
		return "\<BS>"
endfunction
inoremap <silent> <BS> <C-r>=BetterBackSpace()<CR>
" }}}2

" folds {{{2
" 'smart' <Tab>
nnoremap <expr> <Tab> foldlevel('.') > 0 ? "za" : "\<Tab>"
nnoremap <expr> <S-Tab> &foldlevel > 0 ? "zM" : "zR"
nnoremap <leader>z zfap

function! InsertFoldMarker(...) abort
	let l:cur_line = getline('.')
	let l:cur_col  = col('.')
	let l:markers  = split(&l:fmr, ',')
	let l:marker   = l:markers[0]
	let l:level    = foldlevel('.')
	let l:level    = l:level == 0 ? '1' : l:level
	if (a:0) && len(l:markers) > 1
		let l:marker = l:markers[1]
	endif
	let l:cms = split(&l:cms, '%s')
	if (a:0) && len(l:cms) > 1
		" TODO: handle paired comment markers
		let l:cms = l:cms[1]
	else
		let l:cms = l:cms[0]
	endif
	let l:cnt = count(l:cur_line, l:cms)
	let l:space = l:cur_col == 1 && len(l:cur_line) < 2 ? '' : ' '
	if l:cnt % 2 == 0
		exe "norm! m1A".l:space.l:cms." ".l:marker.l:level."\<Esc>`1"
	else
		exe "norm! m1A ".l:marker.l:level."\<Esc>`1"
	endif
	return ''
endfunction

nnoremap <leader><Tab>  :call InsertFoldMarker()<CR>
nnoremap <leader>1<Tab> :call InsertFoldMarker(1)<CR>
inoremap <localleader><Tab>  <C-r>=InsertFoldMarker()<CR>
inoremap <localleader>1<Tab> <C-r>=InsertFoldMarker(1)<CR>
" }}}2

" count matches @ vim wiki
map <leader>* *<C-O>:%s///gn<CR>

" insert newlines above and beyond {{{2
nnoremap <leader>j mjo<Esc>`j
inoremap <localleader>j <Esc>mjo<C-o>`j
nnoremap <leader>k mkO<Esc>`k
inoremap <localleader>k <Esc>mkO<C-o>`k
" }}}2

" buffers {{{2
nnoremap gb :ls<CR>:b
nnoremap <C-Tab> <C-^>
" also a lang switch
inoremap <C-Tab> <C-^>
nnoremap <leader>q :bp<bar>bd#<CR>
nnoremap <leader>0 :%bd<CR>

" fuzzy search #plugins {{{2
nnoremap <leader>b :Buffers<CR>
nnoremap <leader>m :History<CR>
nnoremap <leader>f :FZF<CR>

" copypaste {{{2
map Y y$
nnoremap gy :%y+<CR>

" better than <leader>ohmygodimissedthatnextbutton
map! <S-Insert> *
vmap  "*d
vmap <C-Del> "*d
vmap <S-Del> "*d
vmap <C-Insert> "*y
vmap <S-Insert> "-d"*P
nmap <S-Insert> "*P

" QoL {{{2
nnoremap <C-W>e <C-W>=
nnoremap vv ^vg_
vnoremap < <gv
vnoremap > >gv
nnoremap <leader>cd :cd %:p:h<CR>
" screen line scroll - very useful with wrap on
" https://bluz71.github.io/2017/05/15/vim-tips-tricks.html
nnoremap <expr> j v:count ? (v:count > 5 ? "m'" . v:count : '') . 'j' : 'gj'
nnoremap <expr> k v:count ? (v:count > 5 ? "m'" . v:count : '') . 'k' : 'gk'

" Search
" also by Marco Trosi
vnoremap / y/\V^R"<CR>
vnoremap ? y/\V\<^R"\><CR>
vnoremap * y/\V\<^R"<CR>
vnoremap # y/\V^R"\><CR>

" specials {{{2
nnoremap <F2> :Lex<CR>
nnoremap <F4> :set hlsearch! hlsearch?<cr>
nnoremap <F6> :setl wrap! wrap?<CR>
imap <F6> <C-O><F6>
nnoremap <F11> :so $MYVIMRC<CR>
nnoremap <F12> :e $MYVIMRC<CR>
nnoremap <S-F12> :e ~\vimfiles\packages.vim<CR>

" plugins {{{1
runtime packages.vim

" important!
filetype plugin indent on
syntax enable

" autocommands {{{1
if has("autocmd")
augroup reload_vimrc " {{{2
	autocmd!
	autocmd BufWritePost [_.g]\\\{-\}vimrc,init.vim nested source $MYVIMRC | echo 'vimrc reloaded'
augroup END

augroup ft_vim " {{{2
" because vim commentary doesn't know anything
	autocmd!
	autocmd FileType vim setlocal com=sO:\"\ -,mO:\"\ \ ,eO:\"\",:\"
	\ commentstring=\"%s
augroup END

augroup ft_python " {{{2
	au!
	au FileType python setlocal makeprg=python\ %
	au FileType python nnoremap <buffer> <F7> :up<bar>make<CR>
	au FileType python nnoremap <buffer> <leader>d iprint(f'***=line('.')<CR>*** : {}')<Esc>==0f{a
	au FileType python iabbr <buffer> dbg print(f'***=line('.')<CR>***: {}')<Esc>0f{a
augroup END

" vim-dotoo  {{{2
augroup p_vimDotoo
	autocmd!
	autocmd BufEnter *.dotoo packadd vim-dotoo
	autocmd BufRead, BufNewFile, BufEnter *.dotoo filetype plugin indent on
	autocmd BufRead, BufNewFile, BufEnter *.dotoo syntax on
augroup END

" vim organizer {{{2
let g:ft_ignore_pat = '\.org'
augroup p_VimOrganizer
	autocmd!
	" autocmd! BufRead,BufWrite,BufWritePost,BufNewFile *.org
	autocmd BufEnter *.org filetype plugin indent on
	autocmd BufEnter *.org syntax on
	autocmd BufEnter *.org packadd VimOrganizer
	autocmd BufEnter *.org call org#SetOrgFileType()
augroup END
command! OrgCapture :call org#CaptureBuffer()
command! OrgCaptureFile :call org#OpenCaptureFile()
" }}}2
endif

" plugin settings {{{1
" maybe should place this into `packages.vim`

" Use fd for ctrlp. {{{2
if executable('fd')
	let g:ctrlp_user_command = 'fd -c never "" "%s"'
	let g:ctrlp_use_caching = 0
endif

" FZF {{{2
" To use ripgrep instead of ag:
command! -bang -nargs=* Rg
  \ call fzf#vim#grep(
  \   'rg --column --line-number --no-heading --color=always '.shellescape(<q-args>), 1,
  \   <bang>0 ? fzf#vim#with_preview('up:60%')
  \           : fzf#vim#with_preview('right:50%:hidden', '?'),
  \   <bang>0)

nnoremap <C-p> :FZF<CR>
" Insert mode completion
imap <c-x><c-k> <plug>(fzf-complete-word)
imap <c-x><c-f> <plug>(fzf-complete-path)
imap <c-x><c-j> <plug>(fzf-complete-file-ag)
imap <c-x><c-l> <plug>(fzf-complete-line)

" commands {{{1
command! WipeReg for i in range(34,122) | silent! call setreg(nr2char(i), []) | endfor
" }}}1

" XXX: don't put anything important below this line

" XXX: oh nice, it doesn't load 'opt' packages
" XXX: for :debug:
" packloadall

